<!DOCTYPE html>

<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Proposed Algorithm</title>
  <link rel="stylesheet" href="js/leaflet.css" />
  <link href="js/bootstrap.min.css" rel="stylesheet" />
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 0;
    }

    .map {
      /* position: absolute; */
      width: 100%;
      height: 350px;
      /* top: 0; */
      /* bottom: 0; */
    }
  </style>
  <script src="js/jquery-3.2.1.min.js"></script>
  <script src="js/leaflet.js"></script>
  <script src="js/L.Map.Sync.js"></script>
  <script src="js/turf.min.js"></script>
  <!-- <script src="../qgis/polygon.geojson" type="text/javascript"></script> -->
  <script src="sd_data.geojson"></script>
  <!-- <script src="sd_data_rewind.geojson"></script> -->
  <script src="utils.js"></script>
</head>

<body>
  <div class="container">
    <div class="row">
      <div class="col habib">Habib Algorithm</div>
      <div class="col proposed">
        Proposed Algorithm
      </div>
      <div class="col combined">
        <span>Select Polygon
          <select id="selectPolygon"></select>
          <span id="polygonInfo">Polygon Area</span>
        </span>
        <p></p>
        <span>Select Point
          <select id="selectPoint"></select>
        </span>
        <p></p>
        <span>Required Area</span>
        <input type="text" id="requiredArea">
        <p></p>
        <button onclick="performSplit()">Perform Split</button>
      </div>
    </div>
</body>
<script>
  var $habib = $(".habib");
  var $proposed = $(".proposed");
  var $combined = $(".combined");
  var maps_habib = {};
  var maps_proposed = {};
  var maps_combined = {};
  var polygons_habib = {};
  var polygons_proposed = {};
  var polygons_combined = {};
  var LnewPolygonHabib; // placeholder for habibs result
  var LnewPolygonProposed; // placeholder for proposed result
  var LnewPolygonHabibCombined;
  var LnewPolygonProposedCombined; 
  var selectedPolygon = 0;
</script>
<script>
  var row = 1;
  const $selectPolygon = $('#selectPolygon');
  polygonLayer.features
    .forEach((polygon, index) => {
      $selectPolygon.append($('<option></option>').attr('value', index).text(index));
    });
  $selectPolygon.change(function () {
    selectedPolygon = $(this).val();
    console.log('selectedPolygon: ', selectedPolygon);
    // alert(selectedPolygon);
    points = polygonLayer.features[selectedPolygon].geometry.coordinates[0].slice();
    points.pop();
    // debugger;
    if(calcPolygonAreaShoelace(points) < 0) {
      points = polygonLayer.features[selectedPolygon].geometry.coordinates[0].reverse().slice();
    }
    $('#polygonInfo').text('Polygon Area: ' + calcPolygonAreaShoelace(points));
    const $selectPoint = $('#selectPoint');
    // debugger;
    $selectPoint.empty();
    // create a layer to hold labels
    points
      .forEach((xy, index) => {
        $selectPoint.append($('<option></option>').attr('value', index).text(index));
        const label = L.tooltip({
          direction: "auto",
        })
          .setLatLng({ lat: xy[1], lng: xy[0] })
          .setContent(`<span>${index}</span>`)
          // .setContent(`<span>${numberToCapitalLetter(index + 1)}</span>`)
          .addTo(labelLayer_habib[row]);
      });
    maps_habib[row].fitBounds(polygons_habib[row].getLayers()[selectedPolygon].getBounds());
  })
  var points = polygonLayer.features[selectedPolygon].geometry.coordinates[0].slice();
  if(calcPolygonAreaShoelace(points) < 0) {
      points = polygonLayer.features[selectedPolygon].geometry.coordinates[0].reverse().slice();
    }
  const $selectPoint = $('#selectPoint');
  points.pop();
  points
    .forEach((xy, index) => {
      $selectPoint.append($('<option></option>').attr('value', index).text(index));
    });
  function performSplit() {
    var selectedPointIndex = document.getElementById('selectPoint').value;
    console.log('selectedPointIndex: ', selectedPointIndex);
    var requiredArea = document.getElementById('requiredArea').value;
    console.log('requiredArea: ', requiredArea);
    if (requiredArea > calcPolygonAreaShoelace(points)) {
      alert('Required Area is greater than Polygon Area');
    }
    var start = performance.now();
    habib(selectedPointIndex, requiredArea);
    var end = performance.now();
    var timeTakenHabib = end - start;
    $habib_info.html('Time Taken: ' + timeTakenHabib.toFixed(2) + ' ms');

    var start = performance.now();
    proposed(selectedPointIndex, requiredArea);
    var end = performance.now();
    var timeTakenProposed = end - start;
    $proposed_info.html('Time Taken: ' + timeTakenProposed.toFixed(2) + ' ms');
    
    // combined();
  }
</script>
<script algo="Habib">
  var $habib11 = $("<div></div>").addClass("map").attr({
    id: "habibMap" + row,
  });
  $habib.append($habib11);
  maps_habib[row] = L.map("habibMap" + row, {
    center: [35, 0],
    zoom: 2,
    crs: L.CRS.Simple,
    zoomControl: false,
  });
  var $habib_info = $("<div></div>").addClass("info").attr({
    id: "habibInfo" + row,
  });
  $habib11.after($habib_info);
  polygons_habib[row] = L.geoJSON(polygonLayer).addTo(maps_habib[row]);
  maps_habib[row].fitBounds(polygons_habib[row].getLayers()[0].getBounds());
  var labelLayer_habib = (typeof labelLayer_proposed === "undefined") ? {} : labelLayer_habib;
  labelLayer_habib[row] = L.featureGroup().addTo(maps_habib[row]);
  points.pop();
  points
    .forEach((xy, index) => {
      const label = L.tooltip({
        direction: "auto",
      })
        .setLatLng({ lat: xy[1], lng: xy[0] })
        .setContent(`<span>${index}</span>`)
        // .setContent(`<span>${numberToCapitalLetter(index + 1)}</span>`)
        .addTo(labelLayer_habib[row]);
    });
    $('#polygonInfo').text('Polygon Area: ' + calcPolygonAreaShoelace(points));
  var layerSwitcher_habib = L.control.layers({}, { "labels": labelLayer_habib[row] }, { collapsed: false }).addTo(maps_habib[row]);
  function habib(selectedPointIndex, requiredArea) {
    var row = 1;
    console.time('Habib Execution Time');

    // create a layer to hold labels
    var labelLayer_habib = (typeof labelLayer_habib === "undefined") ? {} : labelLayer_habib;
    labelLayer_habib[row] = L.featureGroup().addTo(maps_habib[row]);

    var points_habib = (typeof points_habib === 'undefined') ? {} : points_habib;
    points_habib[row] = polygonLayer.features[selectedPolygon].geometry.coordinates[0].slice();
    points_habib[row].pop();
    if(calcPolygonAreaShoelace(points_habib[row]) < 0) {
      points_habib[row] = polygonLayer.features[selectedPolygon].geometry.coordinates[0].reverse().slice();
    }
    // add labels to each vertex of the polygon
    points_habib[row]
      .forEach((xy, index) => {
        // console.log('xy: ', xy);
        const label = L.tooltip({
          direction: "auto",
        })
          .setLatLng({ lat: xy[1], lng: xy[0] })
          .setContent(`<span>${index}</span>`)
          // .setContent(`<span>${numberToCapitalLetter(index + 1)}</span>`)
          .addTo(labelLayer_habib[row]);
        // Apply styling to label if needed

      });
    // const selectedPointIndex = 0;
    const selectedPoint = points_habib[row][selectedPointIndex];
    // const requiredArea = 1000;

    const frontPoints = points_habib[row].splice(0, selectedPointIndex);
    points_habib[row] = [...points_habib[row], ...frontPoints];
    // console.log('points_habib[row]: ', points_habib[row]);  
    // Habib One Point and Area Algorithm
    for (let i = 2; i < points_habib[row].length; i++) {
      if (calcPolygonAreaShoelace(points_habib[row].slice(0, i)) >= requiredArea) {
        const LVertex = points_habib[row][i - 2];
        const NVertex = points_habib[row][i - 1];
        const areaDiff =
          requiredArea - calcPolygonAreaShoelace(points_habib[row].slice(0, i - 1));
        const pDist = (2 * areaDiff) / (distance(LVertex, selectedPoint) * Math.sin(anticlockwiseAngle2D(NVertex, LVertex, selectedPoint) * Math.PI / 180));
        const pNewLatLng = [
          LVertex[0] +
          ((NVertex[0] - LVertex[0]) * pDist) / distance(NVertex, LVertex),
          LVertex[1] +
          ((NVertex[1] - LVertex[1]) * pDist) / distance(NVertex, LVertex),
        ];
        var newPolygon = points_habib[row].slice(0, i - 1);
        newPolygon.push(pNewLatLng);
        
        if(maps_habib[row].hasLayer(LnewPolygonHabib)){
          maps_habib[row].removeLayer(LnewPolygonHabib);
        }
         LnewPolygonHabib = L.polygon(L.GeoJSON.coordsToLatLngs(newPolygon), {
          color: "red",
        }).addTo(maps_habib[row]);
        // debugger;
        if(maps_combined[row].hasLayer(LnewPolygonHabibCombined)){
          maps_combined[row].removeLayer(LnewPolygonHabibCombined);
        }
        LnewPolygonHabibCombined = L.polygon(L.GeoJSON.coordsToLatLngs(newPolygon), {
          color: "red",
        }).addTo(maps_combined[row]);
        break;
      }
      //
    }
    console.timeEnd('Habib Execution Time');
  }
</script>
<script algo="proposed">
  var $proposed11 = $("<div></div>").addClass("map").attr({
    id: "proposedMap" + row,
  });
  $proposed.append($proposed11);
  maps_proposed[row] = L.map("proposedMap" + row, {
    center: [35, 0],
    zoom: 2,
    crs: L.CRS.Simple,
    zoomControl: false,
  });
  var $proposed_info = $("<div></div>").addClass("info").attr({
    id: "proposedInfo" + row,
  });
  $proposed11.after($proposed_info);
  polygons_proposed[row] = L.geoJSON(polygonLayer).addTo(maps_proposed[row]);
  maps_proposed[row].fitBounds(polygons_proposed[row].getBounds());
  maps_proposed[row].invalidateSize();

  function proposed(selectedPointIndex, requiredArea) {
    var row = 1;
    console.time('Proposed Execution Time');
    // labelLayer_proposed[row] = L.featureGroup().addTo(maps_proposed[row]);
    // add labels to each vertex of the polygon
    var points_proposed = (typeof points_proposed === 'undefined') ? {} : points_proposed;
    points_proposed[row] = polygonLayer.features[selectedPolygon].geometry.coordinates[0].slice();
    if(calcPolygonAreaShoelace(points_proposed[row]) < 0) {
      points_proposed[row].reverse();
    }
    const selectedPointProposed = points_proposed[row][selectedPointIndex];
    const frontPointsProposed = points_proposed[row].splice(0, selectedPointIndex);
    // console.log('frontPointsProposed: ', frontPointsProposed);
    points_proposed[row] = [...points_proposed[row], ...frontPointsProposed];
    // add labels to each vertex of the polygon
    // points_proposed[row]
    //   .forEach((xy, index) => {
    //     const label = L.tooltip({
    //       direction: "auto",
    //     })
    //       .setLatLng({ lat: xy[1], lng: xy[0] })
    //       .setContent(`<span>${index}</span>`)
    //       // .setContent(`<span>${numberToCapitalLetter(index + 1)}</span>`)
    //       .addTo(labelLayer_proposed[row]);
    //     // Apply styling to label if needed
    //   });
    // Proposed One Point and Area Algorithm
    var intAngles = getPolygonAngles(points_proposed[row]);

    let concaveIndex = [];
    for (let i = 0; i < intAngles.length; i++) {
      if (intAngles[i] > 180) {
        concaveIndex.push(i);
      }
    }
    var convexIndex = [];
    for (let i = 0; i < intAngles.length; i++) {
      if (intAngles[i] < 180) {
        convexIndex.push(i);
      }
    }
    var pointsSlopes = points_proposed[row].map((point, index) => {
      return {
        vertexindex: index,
        angleXaxis: angleWithXAxis(points_proposed[row][0], point),
      };
    });
    // debugger;
    var baseLineForAngleIndex = concaveIndex.includes(1) ? convexIndex[1] : 1;
    var pointAngles = pointsSlopes.map((point) =>
      point.angleXaxis - pointsSlopes[baseLineForAngleIndex].angleXaxis >= 0
        ? point.angleXaxis - pointsSlopes[baseLineForAngleIndex].angleXaxis
        : point.angleXaxis - pointsSlopes[baseLineForAngleIndex].angleXaxis + 360
    );
    pointAngles[0] = 0;
    pointsSlopes.forEach((item, i) => {
      pointsSlopes[i].angle = pointAngles[i];
    });
    pointsSlopes.sort((a, b) => a.angle - b.angle);
    var pointsSlopesIndex = pointsSlopes.map((point, index) => {
      return point.vertexindex;
    });
    // debugger
    var convexIndex = pointsSlopesIndex.filter((element) => !concaveIndex.includes(element) || element == 0);
    var rearrangedPoints = pointsSlopesIndex.map((index) => {
      return points_proposed[row][index];
    });
    var rearrangedPointsConvex = convexIndex.map((index) => {
      return points_proposed[row][index];
    });
    // find last partition polygon
    for (let i = 2; i < rearrangedPointsConvex.length; i++) {
      // debugger
      var partitionPolygon = rearrangedPointsConvex.slice(0, i + 1); // slice returns i-1 so parameter is i+1
      // debugger;
      partitionPolygon.push(selectedPointProposed);
      // debugger;
      var partitionPolygonTurf = turf.polygon([partitionPolygon]);
      L.geoJson(partitionPolygonTurf, { color: 'pink' }).addTo(maps_proposed[row]);
      partitionPolygon.pop();
      var intersection = turf.intersect(
        polygonLayer.features[selectedPolygon],
        partitionPolygonTurf
      );
      var areaIntersection = [];
      debugger;
      if (!intersection) {
        areaIntersection.push(0);
      } else
      if (intersection.geometry.coordinates.length <= 1) {
        areaIntersection.push(calcPolygonAreaShoelace(
          intersection.geometry.coordinates[0]
        ));
      } else {
        for (
          let j = 0;
          j < intersection.geometry.coordinates.length;
          j++
        ) {
          areaIntersection.push(calcPolygonAreaShoelace(
            intersection.geometry.coordinates[j][0]
          ));
        }
      }
      var interiorarea = areaIntersection.reduce((x, y) => x + y);

      // stop when interior area gets larger than required area
      if (interiorarea - requiredArea >= 0.01) {
        var LVertex = rearrangedPointsConvex[i - 1];
        var NVertex = points_proposed[row][pointsSlopesIndex[i - 1] + 1];
        break;
      }
    }
    // console.log('%c partitionPoly' + partitionPolygon, 'background: #FFF; color:red ')

    function derivePartitionPoly(rearrangedPointsConvex, partitionPolygon, LVertex, NVertex, requiredArea) {
      // debugger;
      const LastPartitionPolygon = partitionPolygon;
      LastPartitionPolygon.push(selectedPointProposed);
      if (LastPartitionPolygon.length <= 3) {
        LastPartitionPolygon.push(selectedPointProposed);
        var threePointcase = true;
      }
      var LastPartitionPolygonTurf = turf.polygon([LastPartitionPolygon]);
      LastPartitionPolygon.pop();
      if (threePointcase) {
        LastPartitionPolygon.pop();
        threePointcase = false;
      }
      debugger;
      L.geoJson(LastPartitionPolygonTurf, {style: {color: 'red'}}).addTo(maps_proposed[row]);
      var intersection = turf.intersect(
        polygonLayer.features[selectedPolygon],
        LastPartitionPolygonTurf
      );

      var areaIntersection = [];
      // debugger;
      if (!intersection) {
        areaIntersection.push(0);
      } else if (intersection.geometry.coordinates.length <= 1) {
        areaIntersection.push(calcPolygonAreaShoelace(
          intersection.geometry.coordinates[0]
        ));
      } else {
        for (
          let j = 0;
          j < intersection.geometry.coordinates.length;
          j++
        ) {
          areaIntersection.push(calcPolygonAreaShoelace(
            intersection.geometry.coordinates[j][0]
          ));
        }
      }
      var interiorarea = areaIntersection.reduce((x, y) => x + y);
      // L.geoJson(intersection, { color: "green" }).addTo(maps_proposed[row]);

      const areaDiff = requiredArea - interiorarea;

      // debugger;
      if (areaDiff <= 1) { //tolerance level
        return intersection
      } else {
        const pDist = (2 * areaDiff) / (distance(LVertex, selectedPointProposed) * Math.sin(anticlockwiseAngle2D(NVertex, LVertex, selectedPointProposed) * Math.PI / 180));

        const pNewLatLng = [
          LVertex[0] +
          ((NVertex[0] - LVertex[0]) * pDist) / distance(NVertex, LVertex),
          LVertex[1] +
          ((NVertex[1] - LVertex[1]) * pDist) / distance(NVertex, LVertex),
        ];

        LastPartitionPolygon.splice(LastPartitionPolygon.length, 0, pNewLatLng);
        // L.polygon(L.GeoJSON.coordsToLatLngs(LastPartitionPolygon), {
        //   color: "red",
        // }).addTo(maps_proposed[row]);
        const FinalPartitionPolygon = derivePartitionPoly(rearrangedPointsConvex, LastPartitionPolygon, pNewLatLng, NVertex, requiredArea);
        // 
        return FinalPartitionPolygon;
      }
    }
    const FinalPartitionPolygon = derivePartitionPoly(rearrangedPointsConvex, partitionPolygon.slice(0, -1), LVertex, NVertex, requiredArea);
    // console.log('NVertex: ', NVertex);
    // console.log('LVertex: ', LVertex);

    if(maps_proposed[row].hasLayer(LnewPolygonProposed)){
      maps_proposed[row].removeLayer(LnewPolygonProposed);
    }
    LnewPolygonProposed = L.geoJson(FinalPartitionPolygon, {
      color: 'black'
    }).addTo(maps_proposed[row]);

    if(maps_combined[row].hasLayer(LnewPolygonProposedCombined)){
      maps_combined[row].removeLayer(LnewPolygonProposedCombined);
    }
    LnewPolygonProposedCombined = L.geoJson(FinalPartitionPolygon, {
      color: 'black'
    }).addTo(maps_combined[row]);
    console.timeEnd('Proposed Execution Time');
  }
</script>
<script>
  var $combined11 = $("<div></div>").addClass("map").attr({
    id: "combinedMap" + row,
  });
  $combined.append($combined11);
  maps_combined[row] = L.map("combinedMap" + row, {
    center: [35, 0],
    zoom: 2,
    crs: L.CRS.Simple,
    zoomControl: false,
  })
  polygons_combined[row] = L.geoJSON(polygonLayer).addTo(maps_combined[row]);
  maps_combined[row].fitBounds(polygons_combined[row].getBounds());

  maps_habib[row].invalidateSize();
  maps_habib[1].sync(maps_proposed[1]);
  maps_proposed[1].sync(maps_habib[1]);
  maps_habib[1].sync(maps_combined[1]);
  maps_combined[1].sync(maps_habib[1]);
</script>

</html>