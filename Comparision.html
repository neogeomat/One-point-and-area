<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Proposed Algorithm</title>
  <link rel="stylesheet" href="js/leaflet.css" />
  <link href="js/bootstrap.min.css" rel="stylesheet" />
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 0;
    }

    .map {
      /* position: absolute; */
      width: 100%;
      height: 350px;
      /* top: 0; */
      /* bottom: 0; */
    }
  </style>
  <script src="js/jquery-3.2.1.min.js"></script>
  <script src="js/leaflet.js"></script>
  <script src="js/L.Map.Sync.js"></script>
  <script src="js/turf.min.js"></script>
  <script src="js/convex-hull.js"></script>
  <!-- <script src="sd_data.geojson"></script> -->
  <script src="sd_data_final.geojson"></script>
  <script src="utils.js"></script>
</head>

<body>
  <div class="container">
    <div class="row">
      <div class="col habib">Habib Algorithm</div>
      <div class="col proposed">Proposed Algorithm
      </div>
      <div class="col combined">
        <span>
          Select Polygon
          <select id="selectPolygon"></select>
          <span id="polygonInfo">Polygon Area</span>
        </span>
        <p></p>
        <span>
          Select Point
          <select id="selectPoint"></select>
        </span>
        <p></p>
        <span>Required Area</span>
        <input type="text" id="requiredArea">
        <p></p>
        <button onclick="performSplit()">Perform Split</button>
        <p></p>
        <span>Combined Results</span>
      </div>
    </div>
</body>
<script>
  var $habib = $(".habib");
  var $proposed = $(".proposed");
  var $combined = $(".combined");
  var maps_habib = {};
  var maps_proposed = {};
  var maps_combined = {};
  var polygons_habib = {};
  var polygons_proposed = {};
  var polygons_combined = {};
  var LnewPolygonHabib;
  // placeholder for habibs result
  var LnewPolygonProposed;
  // placeholder for proposed result
  var LnewPolygonHabibCombined;
  var LnewPolygonProposedCombined;
  var selectedPolygon = 0;
</script>
<script>
  var row = 1;
  const $selectPolygon = $('#selectPolygon');
  polygonLayer.features.forEach((polygon, index) => {
    $selectPolygon.append($('<option></option>').attr('value', index).text(index));
  }
  );
  $selectPolygon.change(function () {
    selectedPolygon = $(this).val();
    console.log('selectedPolygon: ', selectedPolygon);
    // alert(selectedPolygon);
    points = polygonLayer.features[selectedPolygon].geometry.coordinates[0].slice();
    // points.pop();
    
    if (calcPolygonAreaShoelace(points) < 0) {
      points = polygonLayer.features[selectedPolygon].geometry.coordinates[0].reverse().slice();
    }
    $('#polygonInfo').text('Polygon Area: ' + calcPolygonAreaShoelace(points));
    const $selectPoint = $('#selectPoint');
    
    $selectPoint.empty();
    // create a layer to hold labels
    
    labelLayer_habib[row].clearLayers();
    points.forEach((xy, index) => {
      $selectPoint.append($('<option></option>').attr('value', index).text(index));
      const label = L.tooltip({
        direction: "auto",
      }).setLatLng({
        lat: xy[1],
        lng: xy[0]
      }).setContent(`<span>${index}</span>`)// .setContent(`<span>${numberToCapitalLetter(index + 1)}</span>`)
        .addTo(labelLayer_habib[row]);
    }
    );
    maps_habib[row].fitBounds(polygons_habib[row].getLayers()[selectedPolygon].getBounds());
  })
  var points = polygonLayer.features[selectedPolygon].geometry.coordinates[0].slice();
  if (calcPolygonAreaShoelace(points) < 0) {
    points = polygonLayer.features[selectedPolygon].geometry.coordinates[0].reverse().slice();
  }
  const $selectPoint = $('#selectPoint');
  // points.pop();
  points.forEach((xy, index) => {
    $selectPoint.append($('<option></option>').attr('value', index).text(index));
  }
  );
  function performSplit() {
    var selectedPointIndex = document.getElementById('selectPoint').value;
    console.log('selectedPointIndex: ', selectedPointIndex);
    var requiredArea = document.getElementById('requiredArea').value;
    console.log('requiredArea: ', requiredArea);
    if (requiredArea > calcPolygonAreaShoelace(points)) {
      alert('Required Area is greater than Polygon Area');
    }
    
    habib(selectedPointIndex, requiredArea);
    proposed(selectedPointIndex, requiredArea);
    // combined();
  }
</script>
<script algo="Habib">
  var $habib11 = $("<div></div>").addClass("map").attr({
    id: "habibMap" + row,
  });
  $habib.append($habib11);
  maps_habib[row] = L.map("habibMap" + row, {
    center: [35, 0],
    zoom: 2,
    crs: L.CRS.Simple,
    zoomControl: false,
  });
  var $habib_info = $("<div></div>").addClass("info").attr({
    id: "habibInfo" + row,
  });
  $habib11.after($habib_info);
  polygons_habib[row] = L.geoJSON(polygonLayer).addTo(maps_habib[row]);
  maps_habib[row].fitBounds(polygons_habib[row].getLayers()[0].getBounds());
  var labelLayer_habib = (typeof labelLayer_habib === "undefined") ? {} : labelLayer_habib;
  labelLayer_habib[row] = L.featureGroup().addTo(maps_habib[row]);
  // points.pop();
  labelLayer_habib[row].clearLayers();
  points.forEach((xy, index) => {
    const label = L.tooltip({
      direction: "auto",
    }).setLatLng({
      lat: xy[1],
      lng: xy[0]
    }).setContent(`<span>${index}</span>`)// .setContent(`<span>${numberToCapitalLetter(index + 1)}</span>`)
      .addTo(labelLayer_habib[row]);
  }
  );
  $('#polygonInfo').text('Polygon Area: ' + calcPolygonAreaShoelace(points));
  var layerSwitcher_habib = L.control.layers({}, {
    "labels": labelLayer_habib[row]
  }, {
    collapsed: false
  }).addTo(maps_habib[row]);
  function habib(selectedPointIndex, requiredArea) {
    var row = 1;
    var start = performance.now();
    console.time('Habib Execution Time');
    // create a layer to hold labels
    var labelLayer_habib = (typeof labelLayer_habib === "undefined") ? {} : labelLayer_habib;
    labelLayer_habib[row] = L.featureGroup();
    // labelLayer_habib[row].addTo(maps_habib[row]);

    var points_habib = (typeof points_habib === 'undefined') ? {} : points_habib;
    points_habib[row] = polygonLayer.features[selectedPolygon].geometry.coordinates[0].slice();
    points_habib[row].pop();
    if (calcPolygonAreaShoelace(points_habib[row]) < 0) {
      points_habib[row] = polygonLayer.features[selectedPolygon].geometry.coordinates[0].reverse().slice();
    }
    // add labels to each vertex of the polygon

    labelLayer_habib[row].clearLayers();
    points_habib[row].forEach((xy, index) => {
      // console.log('xy: ', xy);
      const label = L.tooltip({
        direction: "auto",
      }).setLatLng({
        lat: xy[1],
        lng: xy[0]
      }).setContent(`<span>${index}</span>`)// .setContent(`<span>${numberToCapitalLetter(index + 1)}</span>`)
        .addTo(labelLayer_habib[row]);
      // Apply styling to label if needed

    }
    );
    // const selectedPointIndex = 0;
    const selectedPoint = points_habib[row][selectedPointIndex];
    // const requiredArea = 1000;

    const frontPoints = points_habib[row].splice(0, selectedPointIndex);
    points_habib[row] = [...points_habib[row], ...frontPoints];
    // console.log('points_habib[row]: ', points_habib[row]);  
    // Habib One Point and Area Algorithm
    for (let i = 2; i < points_habib[row].length; i++) {
      if (calcPolygonAreaShoelace(points_habib[row].slice(0, i)) >= requiredArea) {
        const LVertex = points_habib[row][i - 2];
        const NVertex = points_habib[row][i - 1];
        const areaDiff = requiredArea - calcPolygonAreaShoelace(points_habib[row].slice(0, i - 1));
        const pDist = (2 * areaDiff) / (distance(LVertex, selectedPoint) * Math.sin(anticlockwiseAngle2D(selectedPoint, LVertex,NVertex ) * Math.PI / 180));
        const pNewLatLng = [LVertex[0] + ((NVertex[0] - LVertex[0]) * pDist) / distance(NVertex, LVertex), LVertex[1] + ((NVertex[1] - LVertex[1]) * pDist) / distance(NVertex, LVertex),];
        var newPolygon = points_habib[row].slice(0, i - 1);
        newPolygon.push(pNewLatLng);
        var end = performance.now();
        if (maps_habib[row].hasLayer(LnewPolygonHabib)) {
          maps_habib[row].removeLayer(LnewPolygonHabib);
        }
        LnewPolygonHabib = L.polygon(L.GeoJSON.coordsToLatLngs(newPolygon), {
          color: "red",
        }).addTo(maps_habib[row]);
        
        if (maps_combined[row].hasLayer(LnewPolygonHabibCombined)) {
          maps_combined[row].removeLayer(LnewPolygonHabibCombined);
        }
        LnewPolygonHabibCombined = L.polygon(L.GeoJSON.coordsToLatLngs(newPolygon), {
          color: "red",
        }).addTo(maps_combined[row]);

        var timeTakenHabib = end - start;
    $habib_info.html('Time Taken: ' + timeTakenHabib.toFixed(2) + ' ms');
    // debugger;
    $habib_info.html($habib_info.html() + '<br>' + newPolygon[1]+ selectedPoint+ pNewLatLng) + ' points';
    $habib_info.html($habib_info.html() + '<br>Angle: ' + anticlockwiseAngle2D(newPolygon[1], selectedPoint, pNewLatLng) + ' degrees');
    $habib_info.html($habib_info.html() + '<br><br>newPolygon: ' + JSON.stringify(LnewPolygonHabib.toGeoJSON()));
        break;
      }
      //
    }
    console.timeEnd('Habib Execution Time');
    // debugger;
    return newPolygon;
  }
</script>
<script algo="proposed">
  var $proposed11 = $("<div></div>").addClass("map").attr({
    id: "proposedMap" + row,
  });
  $proposed.append($proposed11);
  maps_proposed[row] = L.map("proposedMap" + row, {
    center: [35, 0],
    zoom: 2,
    crs: L.CRS.Simple,
    zoomControl: false,
  });
  var $proposed_info = $("<div></div>").addClass("info").attr({
    id: "proposedInfo" + row,
  });
  $proposed11.after($proposed_info);
  polygons_proposed[row] = L.geoJSON(polygonLayer).addTo(maps_proposed[row]);
  maps_proposed[row].fitBounds(polygons_proposed[row].getBounds());
  maps_proposed[row].invalidateSize();

  function proposed(selectedPointIndex, requiredArea) {
    var row = 1;
    var start = performance.now();
    console.time('Proposed Execution Time');
    // labelLayer_proposed[row] = L.featureGroup().addTo(maps_proposed[row]);
    // add labels to each vertex of the polygon
    var points_proposed = (typeof points_proposed === 'undefined') ? {} : points_proposed;
    points_proposed[row] = polygonLayer.features[selectedPolygon].geometry.coordinates[0].slice();
    if (calcPolygonAreaShoelace(points_proposed[row]) < 0) {
      points_proposed[row].reverse();
    }
    const selectedPointProposed = points_proposed[row][selectedPointIndex];
    const frontPointsProposed = points_proposed[row].splice(0, selectedPointIndex);
    // console.log('frontPointsProposed: ', frontPointsProposed);
    points_proposed[row] = [...points_proposed[row], ...frontPointsProposed];
    // Proposed One Point and Area Algorithm
    var arrayOfObjects = points_proposed[row].map(function (arr, index) {
      return { x: arr[0], y: arr[1], index: index };
    });

    var convex_hull = convexhull.makeHull(arrayOfObjects);
    convex_hull.sort((a, b) => a.index - b.index)

    convexIndex = convex_hull.map(function (arr) {
      return arr.index;
    });

    if(convexIndex[0] !== 0){
      convexIndex.unshift(0);
    }
    console.log('convexIndexNew: ', convexIndex);    
    convex_hull = convex_hull.map(function (arr) {
      return [arr.x, arr.y];
    });
    
    var rearrangedPointsConvex = convexIndex.map((index) => {
      return points_proposed[row][index];
    }
    );

    // console.log(rearrangedPointsConvex);
     // for checking convex
    // find last partition polygon
    for (let i = 2; i < rearrangedPointsConvex.length; i++) {
      // debugger
      var partitionPolygon = rearrangedPointsConvex.slice(0, i + 1);
      // slice returns i-1 so parameter is i+1
      
      partitionPolygon.push(selectedPointProposed);
      
      var partitionPolygonTurf = turf.polygon([partitionPolygon]);
      // L.geoJson(partitionPolygonTurf, {
      //   color: 'pink'
      // }).addTo(maps_proposed[row]);
      partitionPolygon.pop();
      var intersection = turf.intersect(polygonLayer.features[selectedPolygon], partitionPolygonTurf);
      var areaIntersection = [];
      
      if (!intersection) {
        areaIntersection.push(0);
      } else if (intersection.geometry.coordinates.length <= 1) {
        areaIntersection.push(calcPolygonAreaShoelace(intersection.geometry.coordinates[0]));
      } else {
        for (let j = 0; j < intersection.geometry.coordinates.length; j++) {
          areaIntersection.push(calcPolygonAreaShoelace(intersection.geometry.coordinates[j][0]));
        }
      }
      var interiorarea = areaIntersection.reduce((x, y) => x + y);

      // stop when interior area gets larger than required area
      if (interiorarea - requiredArea >= 0.01) {
        
        var LVertex = rearrangedPointsConvex[i - 1];
        // var NVertex = points_proposed[row][convexIndex[i - 1] + 1];
        var NVertex = rearrangedPointsConvex[i];
        break;
      }
    }
    // console.log('%c partitionPoly' + partitionPolygon, 'background: #FFF; color:red ')

    function derivePartitionPoly(rearrangedPointsConvex, partitionPolygon, LVertex, NVertex, requiredArea) {
      
      const LastPartitionPolygon = partitionPolygon;
      LastPartitionPolygon.push(selectedPointProposed);
      if (LastPartitionPolygon.length <= 3) {
        LastPartitionPolygon.push(selectedPointProposed);
        var threePointcase = true;
      }
      var LastPartitionPolygonTurf = turf.polygon([LastPartitionPolygon]);
      LastPartitionPolygon.pop();
      if (threePointcase) {
        LastPartitionPolygon.pop();
        threePointcase = false;
      }
      
      // L.geoJson(LastPartitionPolygonTurf, {
      //   style: {
      //     color: 'orange'
      //   }
      // }).addTo(maps_proposed[row]);
      var intersection = turf.intersect(polygonLayer.features[selectedPolygon], LastPartitionPolygonTurf);

      var areaIntersection = [];
      
      if (!intersection) {
        areaIntersection.push(0);
      } else if (intersection.geometry.coordinates.length <= 1) {
        areaIntersection.push(calcPolygonAreaShoelace(intersection.geometry.coordinates[0]));
      } else {
        for (let j = 0; j < intersection.geometry.coordinates.length; j++) {
          areaIntersection.push(calcPolygonAreaShoelace(intersection.geometry.coordinates[j][0]));
        }
      }
      var interiorarea = areaIntersection.reduce((x, y) => x + y);
      // L.geoJson(intersection, { color: "green" }).addTo(maps_proposed[row]);

      const areaDiff = requiredArea - interiorarea;
      if (areaDiff <= 1) {
        //tolerance level
        return intersection
      } else {
        const pDist = (2 * areaDiff) / (distance(LVertex, selectedPointProposed) * Math.sin(anticlockwiseAngle2D(selectedPointProposed, LVertex,NVertex ) * Math.PI / 180));

        const pNewLatLng = [LVertex[0] + ((NVertex[0] - LVertex[0]) * pDist) / distance(NVertex, LVertex), LVertex[1] + ((NVertex[1] - LVertex[1]) * pDist) / distance(NVertex, LVertex),];

        LastPartitionPolygon.splice(LastPartitionPolygon.length, 0, pNewLatLng);
        // L.polygon(L.GeoJSON.coordsToLatLngs(LastPartitionPolygon), {
        //   color: "red",
        // }).addTo(maps_proposed[row]);
        const FinalPartitionPolygon = derivePartitionPoly(rearrangedPointsConvex, LastPartitionPolygon, pNewLatLng, NVertex, requiredArea);
        // 
        return FinalPartitionPolygon;
      }
    }
    const FinalPartitionPolygon = derivePartitionPoly(rearrangedPointsConvex, partitionPolygon.slice(0, -1), LVertex, NVertex, requiredArea);
    // console.log('NVertex: ', NVertex);
    // console.log('LVertex: ', LVertex);
    var end = performance.now();
    if (maps_proposed[row].hasLayer(LnewPolygonProposed)) {
      maps_proposed[row].removeLayer(LnewPolygonProposed);
    }
    LnewPolygonProposed = L.geoJson(FinalPartitionPolygon, {
      color: 'black'
    }).addTo(maps_proposed[row]);

    if (maps_combined[row].hasLayer(LnewPolygonProposedCombined)) {
      maps_combined[row].removeLayer(LnewPolygonProposedCombined);
    }
    LnewPolygonProposedCombined = L.geoJson(FinalPartitionPolygon, {
      color: 'black'
    }).addTo(maps_combined[row]);
    console.timeEnd('Proposed Execution Time');
    var timeTakenProposed = end - start;
    $proposed_info.html('Time Taken: ' + timeTakenProposed.toFixed(2) + ' ms');
  }
</script>
<script>
  var $combined11 = $("<div></div>").addClass("map").attr({
    id: "combinedMap" + row,
  });
  $combined.append($combined11);
  maps_combined[row] = L.map("combinedMap" + row, {
    center: [35, 0],
    zoom: 2,
    crs: L.CRS.Simple,
    zoomControl: false,
  })
  polygons_combined[row] = L.geoJSON(polygonLayer).addTo(maps_combined[row]);
  maps_combined[row].fitBounds(polygons_combined[row].getBounds());

  maps_habib[row].invalidateSize();
  maps_habib[1].sync(maps_proposed[1]);
  maps_proposed[1].sync(maps_habib[1]);
  maps_habib[1].sync(maps_combined[1]);
  maps_combined[1].sync(maps_habib[1]);
</script>

</html>