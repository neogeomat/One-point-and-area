<!DOCTYPE html>

<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Proposed Algorithm</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.1/dist/leaflet.css" />
  <link href="js/bootstrap.min.css" rel="stylesheet" />
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 0;
    }

    .map {
      /* position: absolute; */
      width: 100%;
      height: 250px;
      /* top: 0; */
      /* bottom: 0; */
    }
  </style>
  <script src="js/jquery-3.2.1.min.js"></script>
  <script src="js/leaflet.js"></script>
  <script src="js/L.Map.Sync.js"></script>
  <script src="js/turf.min.js"></script>
  <script src="../qgis/polygon.geojson" type="text/javascript"></script>
  <script src="utils.js"></script>
</head>

<body>
  <div class="container">
    <div class="row">
      <!-- <div class="col description"></div> -->
      <div class="col habib">Habib Algorithm</div>
      <div class="col proposed">
        Proposed Algorithm
        <!-- </div>
        <div class="col hybrid">
          Hybrid Algorithm
        </div> -->
      </div>
    </div>
</body>
<script>
  var $habib = $(".habib");
  var $proposed = $(".proposed");
  var $hybrid = $(".hybrid");
  var maps_habib = {};
  var maps_proposed = {};
  var maps_hybrid = {};
  var polygons_habib = {};
  var polygons_proposed = {};
  var polygons_hybrid = {};
</script>
<script algo="Habib">
  var row = 1;
  console.time('Habib Execution Time');
  var $habib11 = $("<div></div>").addClass("map").attr({
    id: "habibMap" + row,
  });
  $habib.append($habib11);
  maps_habib[row] = L.map("habibMap" + row, {
    center: [35, 0],
    zoom: 2,
    crs: L.CRS.Simple,
  });

  polygons_habib[row] = L.geoJSON(polygonLayer).addTo(maps_habib[row]);
  maps_habib[row].fitBounds(polygons_habib[row].getBounds());
  maps_habib[row].invalidateSize();
  // create a layer to hold labels
  var labelLayer_habib = (typeof labelLayer_habib === "undefined") ? {} : labelLayer_habib;
  labelLayer_habib[row] = L.featureGroup().addTo(maps_habib[row]);
  // add labels to each vertex of the polygon
  polygons_habib[row]
    .getLayers()[0]
    .getLatLngs()[0]
    .forEach((latLng, index) => {
      const label = L.tooltip({
        direction: "auto",
      })
        .setLatLng(latLng)
        .setContent(`<span>${index}</span>`)
        .setContent(`<span>${numberToCapitalLetter(index + 1)}</span>`)
      // .addTo(labelLayer_habib[row]);
      // Apply styling to label if needed
    });
  var points_habib = (typeof points_habib === 'undefined') ? {} : points_habib;
  points_habib[row] = polygonLayer.features[0].geometry.coordinates[0];

  const selectedPoint = points_habib[row][0];
  const requiredArea = 150;
  // Habib One Point and Area Algorithm
  for (let i = 2; i < points_habib[row].length; i++) {
    if (calcPolygonAreaShoelace(points_habib[row].slice(0, i)) >= requiredArea) {
      const LVertex = points_habib[row][i - 2];
      const NVertex = points_habib[row][i - 1];
      const areaDiff =
        requiredArea - calcPolygonAreaShoelace(points_habib[row].slice(0, i - 1));
      const pDist = (2 * areaDiff) / (distance(LVertex, selectedPoint) * Math.sin(anticlockwiseAngle2D(NVertex, LVertex, selectedPoint) * Math.PI / 180));
      const pNewLatLng = [
        LVertex[0] +
        ((NVertex[0] - LVertex[0]) * pDist) / distance(NVertex, LVertex),
        LVertex[1] +
        ((NVertex[1] - LVertex[1]) * pDist) / distance(NVertex, LVertex),
      ];
      var newPolygon = points_habib[row].slice(0, i - 1);
      newPolygon.push(pNewLatLng);
      L.polygon(L.GeoJSON.coordsToLatLngs(newPolygon), {
        color: "red",
      }).addTo(maps_habib[row]);
      break;
    }
    //
  }
  console.timeEnd('Habib Execution Time');
</script>
<script algo="proposed">
  console.time('Proposed Execution Time');
  var $proposed11 = $("<div></div>").addClass("map").attr({
    id: "proposedMap" + row,
  });
  $proposed.append($proposed11);
  maps_proposed[row] = L.map("proposedMap" + row, {
    center: [35, 0],
    zoom: 2,
    crs: L.CRS.Simple,
  });
  polygons_proposed[row] = L.geoJSON(polygonLayer).addTo(maps_proposed[row]);
  maps_proposed[row].fitBounds(polygons_proposed[row].getBounds());
  maps_proposed[row].invalidateSize();
  // create a layer to hold labels
  var labelLayer_proposed = (typeof labelLayer_proposed === "undefined") ? {} : labelLayer_proposed;
  labelLayer_proposed[row] = L.featureGroup().addTo(maps_proposed[row]);
  // add labels to each vertex of the polygon
  polygons_proposed[row]
    .getLayers()[0]
    .getLatLngs()[0]
    .forEach((latLng, index) => {
      const label = L.tooltip({
        direction: "auto",
      })
        .setLatLng(latLng)
        .setContent(`<span>${index}</span>`)
        .setContent(`<span>${numberToCapitalLetter(index + 1)}</span>`)
      // .addTo(labelLayer_proposed[row]);
      // Apply styling to label if needed
    });

  var points_proposed = (typeof points_proposed === 'undefined') ? {} : points_proposed;
  points_proposed[row] = polygonLayer.features[0].geometry.coordinates[0];

  // Proposed One Point and Area Algorithm
  var intAngles = getPolygonAngles(points_proposed[row]);
  console.log("intAngles: ", intAngles);
  let concaveIndex = [];
  for (let i = 0; i < intAngles.length; i++) {
    if (intAngles[i] > 180) {
      concaveIndex.push(i);
    }
  }
  console.log("concave index: ", concaveIndex);

  var pointsSlopes = points_proposed[row].map((point, index) => {
    return {
      vertexindex: index,
      angleXaxis: angleWithXAxis(points_proposed[row][0], point),
    };
  });
  var pointAngles = pointsSlopes.map((point) =>
    point.angleXaxis - pointsSlopes[1].angleXaxis >= 0
      ? point.angleXaxis - pointsSlopes[1].angleXaxis
      : point.angleXaxis - pointsSlopes[1].angleXaxis + 360
  );
  pointAngles[0] = 0;
  pointsSlopes.forEach((item, i) => {
    pointsSlopes[i].angle = pointAngles[i];
  });
  pointsSlopes.sort((a, b) => a.angle - b.angle);
  var pointsSlopesIndex = pointsSlopes.map((point, index) => {
    return point.vertexindex;
  });
  var convexIndex = pointsSlopesIndex.filter((element) => !concaveIndex.includes(element));
  // console.log('convexIndex: ', convexIndex);
  var rearrangedPoints = pointsSlopesIndex.map((index) => {
    return points_proposed[row][index];
  });
  var rearrangedPointsConvex = convexIndex.map((index) => {
    return points_proposed[row][index];
  });
  console.log('rearrangedPointsConvex: ', rearrangedPointsConvex);
  // find last partition polygon
  for (let i = 2; i < rearrangedPoints.length; i++) {
    console.log('i: ', i);
    var partitionPolygon = rearrangedPoints.slice(0, i + 1); // slice returns i-1 so parameter is i+1
    // debugger;
    partitionPolygon.push(selectedPoint);
    console.log('partitionPolygon: ', partitionPolygon);
    var partitionPolygonTurf = turf.polygon([partitionPolygon]);
    L.geoJson(partitionPolygonTurf, { color: 'pink' }).addTo(maps_proposed[row]);
    partitionPolygon.pop();
    var intersection = turf.intersect(
      polygonLayer.features[0],
      partitionPolygonTurf
    );
    var areaIntersection = [];
    // debugger;
    if (intersection.geometry.coordinates.length <= 1) {
      areaIntersection.push(calcPolygonAreaShoelace(
        intersection.geometry.coordinates[0]
      ));
    } else {
      for (
        let j = 0;
        j < intersection.geometry.coordinates.length;
        j++
      ) {
        areaIntersection.push(calcPolygonAreaShoelace(
          intersection.geometry.coordinates[j][0]
        ));
      }
    }
    var interiorarea = areaIntersection.reduce((x, y) => x + y);
    L.geoJson(intersection, { color: "green" }).addTo(maps_proposed[row]);
    console.log('areaIntersection: ', areaIntersection);
    // stop when interior area gets larger than required area
    if (interiorarea - requiredArea >= 0.01) {
      var LVertex = rearrangedPoints[i - 1];
      console.log('%c LVertex: ' + LVertex, 'background: #FFF; color:blue ');
      // const NVertex = rearrangedPoints[i+1];
      var NVertex = points_proposed[row][pointsSlopesIndex[i - 1] + 1];
      console.log('%c NVertex: ' + NVertex, 'background: #FFF; color:blue ');
      console.log('%c partitionPoly' + partitionPolygon, 'background: #FFF; color:blue ')
      break;
    }
  }
  console.log('%c partitionPoly' + partitionPolygon, 'background: #FFF; color:red ')

  function derivePartitionPoly(rearrangedPoints, partitionPolygon, LVertex, NVertex, requiredArea) {
    console.log('LVertex: ', LVertex);
    console.log('NVertex: ', NVertex);
    const LastPartitionPolygon = partitionPolygon.slice(0, -2);
    console.log('LastPartitionPolygon: ', LastPartitionPolygon);

    LastPartitionPolygon.push(selectedPoint);
    var LastPartitionPolygonTurf = turf.polygon([LastPartitionPolygon]);
    // L.geoJson(LastPartitionPolygonTurf, {style: {color: 'red'}}).addTo(maps_proposed[row]);
    var intersection = turf.intersect(
      polygonLayer.features[0],
      LastPartitionPolygonTurf
    );
    console.log('intersection: ', intersection);
    var areaIntersection = [];
    debugger;
    if (intersection.geometry.coordinates.length <= 1) {
      areaIntersection.push(calcPolygonAreaShoelace(
        intersection.geometry.coordinates[0]
      ));
    } else {
      for (
        let j = 0;
        j < intersection.geometry.coordinates.length;
        j++
      ) {
        areaIntersection.push(calcPolygonAreaShoelace(
          intersection.geometry.coordinates[j][0]
        ));
      }
    }
    var interiorarea = areaIntersection.reduce((x, y) => x + y);
    // L.geoJson(intersection, { color: "green" }).addTo(maps_proposed[row]);
    console.log('areaIntersection: ', areaIntersection);
    const areaDiff = requiredArea - interiorarea;
    console.log('areaDiff: ', areaDiff);
    debugger;
    if (areaDiff <= 0) {
      return intersection
    } else {
      const pDist = (2 * areaDiff) / (distance(LVertex, selectedPoint) * Math.sin(anticlockwiseAngle2D(NVertex, LVertex, selectedPoint) * Math.PI / 180));
      console.log('pDist: ', pDist);
      const pNewLatLng = [
        LVertex[0] +
        ((NVertex[0] - LVertex[0]) * pDist) / distance(NVertex, LVertex),
        LVertex[1] +
        ((NVertex[1] - LVertex[1]) * pDist) / distance(NVertex, LVertex),
      ];

      console.log('partitionPolygon: ', partitionPolygon);
      console.log('pNewLatLng: ', pNewLatLng);
      LastPartitionPolygon.splice(LastPartitionPolygon.length - 1, 0, pNewLatLng);
      L.polygon(L.GeoJSON.coordsToLatLngs(LastPartitionPolygon), {
        color: "red",
      }).addTo(maps_proposed[row]);
      derivePartitionPoly(rearrangedPoints, LastPartitionPolygon, LVertex, NVertex, requiredArea)
    }
  }
  // derivePartitionPoly(rearrangedPoints, partitionPolygon, LVertex, NVertex, requiredArea);
  console.timeEnd('Proposed Execution Time');
  maps_habib[1].sync(maps_proposed[1]);
  maps_proposed[1].sync(maps_habib[1]);
</script>

</html>