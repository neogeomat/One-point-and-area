<!DOCTYPE html>

<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Proposed Algorithm</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.1/dist/leaflet.css" />
  <link href="js/bootstrap.min.css" rel="stylesheet" />
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 0;
    }

    .map {
      /* position: absolute; */
      width: 100%;
      height: 250px;
      /* top: 0; */
      /* bottom: 0; */
    }
  </style>
  <script src="js/jquery-3.2.1.min.js"></script>
  <script src="js/leaflet.js"></script>
  <script src="js/L.Map.Sync.js"></script>
  <script src="js/turf.min.js"></script>
  <script src="../qgis/polygon.geojson" type="text/javascript"></script>
  <script src="utils.js"></script>
</head>

<body>
  <div class="container">
    <div class="row">
      <!-- <div class="col description"></div> -->
      <div class="col habib">Habib Algorithm</div>
      <div class="col proposed">
        Proposed Algorithm
        <!-- </div>
        <div class="col hybrid">
          Hybrid Algorithm
        </div> -->
      </div>
    </div>
</body>
<script>
  var $habib = $(".habib");
  var $proposed = $(".proposed");
  var $hybrid = $(".hybrid");
  var maps_habib = {};
  var maps_proposed = {};
  var maps_hybrid = {};
  var polygons_habib = {};
  var polygons_proposed = {};
  var polygons_hybrid = {};
</script>
<script algo="Habib">
  var row = 1;
  console.time('Habib Execution Time');
  var $habib11 = $("<div></div>").addClass("map").attr({
    id: "habibMap" + row,
  });
  $habib.append($habib11);
  maps_habib[row] = L.map("habibMap" + row, {
    center: [35, 0],
    zoom: 2,
    crs: L.CRS.Simple,
  });

  polygons_habib[row] = L.geoJSON(polygonLayer).addTo(maps_habib[row]);
  maps_habib[row].fitBounds(polygons_habib[row].getBounds());
  maps_habib[row].invalidateSize();
  // create a layer to hold labels
  var labelLayer_habib = (typeof labelLayer_habib === "undefined") ? {} : labelLayer_habib;
  labelLayer_habib[row] = L.featureGroup().addTo(maps_habib[row]);
  // add labels to each vertex of the polygon
  polygons_habib[row]
    .getLayers()[0]
    .getLatLngs()[0]
    .forEach((latLng, index) => {
      const label = L.tooltip({
        direction: "auto",
      })
        .setLatLng(latLng)
        .setContent(`<span>${index}</span>`)
        .setContent(`<span>${numberToCapitalLetter(index + 1)}</span>`)
        // .addTo(labelLayer_habib[row]);
      // Apply styling to label if needed
    });
  var points_habib = (typeof points_habib === 'undefined') ? {} : points_habib;
  points_habib[row] = polygonLayer.features[0].geometry.coordinates[0];

  const selectedPoint = points_habib[row][0];
  const requiredArea = 800;
  // Habib One Point and Area Algorithm
  for (let i = 2; i < points_habib[row].length; i++) {
    if (calcPolygonAreaShoelace(points_habib[row].slice(0, i)) >= requiredArea) {
      const LVertex = points_habib[row][i - 2];
      const NVertex = points_habib[row][i - 1];
      const areaDiff =
        requiredArea - calcPolygonAreaShoelace(points_habib[row].slice(0, i - 1));
      console.log('areaDiff: ', areaDiff);
      const pDist = (2 * areaDiff) / (distance(LVertex, selectedPoint) * Math.sin(anticlockwiseAngle2D(NVertex,LVertex,selectedPoint)*Math.PI / 180));
      console.log('pDist: ', pDist);
      const pNewLatLng = [
        LVertex[0] +
        ((NVertex[0] - LVertex[0]) * pDist) / distance(NVertex, LVertex),
        LVertex[1] +
        ((NVertex[1] - LVertex[1]) * pDist) / distance(NVertex, LVertex),
      ];
      var newPolygon = points_habib[row].slice(0, i - 1);
      newPolygon.push(pNewLatLng);
      L.polygon(L.GeoJSON.coordsToLatLngs(newPolygon), {
        color: "red",
      }).addTo(maps_habib[row]);
      break;
    }
    //
  }
  console.timeEnd('Habib Execution Time');
</script>
<script algo="proposed">
  console.time('Proposed Execution Time');
  var $proposed11 = $("<div></div>").addClass("map").attr({
    id: "proposedMap" + row,
  });
  $proposed.append($proposed11);
  maps_proposed[row] = L.map("proposedMap" + row, {
    center: [35, 0],
    zoom: 2,
    crs: L.CRS.Simple,
  });
  polygons_proposed[row] = L.geoJSON(polygonLayer).addTo(maps_proposed[row]);
  maps_proposed[row].fitBounds(polygons_proposed[row].getBounds());
  maps_proposed[row].invalidateSize();
  // create a layer to hold labels
  var labelLayer_proposed = (typeof labelLayer_proposed === "undefined") ? {} : labelLayer_proposed;
  labelLayer_proposed[row] = L.featureGroup().addTo(maps_proposed[row]);
  // add labels to each vertex of the polygon
  polygons_proposed[row]
    .getLayers()[0]
    .getLatLngs()[0]
    .forEach((latLng, index) => {
      const label = L.tooltip({
        direction: "auto",
      })
        .setLatLng(latLng)
        .setContent(`<span>${index}</span>`)
        .setContent(`<span>${numberToCapitalLetter(index + 1)}</span>`)
        // .addTo(labelLayer_proposed[row]);
      // Apply styling to label if needed
    });

  var points_proposed = (typeof points_proposed === 'undefined') ? {} : points_proposed;
  points_proposed[row] = polygonLayer.features[0].geometry.coordinates[0];

  // Proposed One Point and Area Algorithm
  var pointsSlopes = points_proposed[row].map((point, index) => {
    return {
      vertexindex: index,
      angleXaxis: angleWithXAxis(points_proposed[row][0], point),
    };
  });
  var pointAngles = pointsSlopes.map((point) =>
    point.angleXaxis - pointsSlopes[1].angleXaxis >= 0
      ? point.angleXaxis - pointsSlopes[1].angleXaxis
      : point.angleXaxis - pointsSlopes[1].angleXaxis + 360
  );
  pointAngles[0] = 0;
  pointsSlopes.forEach((item, i) => {
    pointsSlopes[i].angle = pointAngles[i];
  });
  pointsSlopes.sort((a, b) => a.angle - b.angle);
  var pointsSlopesIndex = pointsSlopes.map((point, index) => {
    return point.vertexindex;
  });

  var rearrangedPoints = pointsSlopesIndex.map((index) => {
    return points_proposed[row][index];
  });
  for (let i = 3; i < rearrangedPoints.length; i++){
    var partitionPolygon = rearrangedPoints.slice(0, i + 1);
        partitionPolygon.push(rearrangedPoints[0]);
        partitionPolygonTurf = turf.polygon([partitionPolygon]);
        // L.geoJson(partitionPolygon,{color:'pink'}).addTo(map);

    var intersection = turf.intersect(
      polygonLayer.features[0],
      partitionPolygonTurf
    );

    var areaIntersection = [];
    // debugger;
    if (intersection.geometry.coordinates.length <= 1) {
      areaIntersection.push(calcPolygonAreaShoelace(
        intersection.geometry.coordinates[0]
      ));
    } else {
      for (
        let j = 0;
        j < intersection.geometry.coordinates.length;
        j++
      ) {
        areaIntersection.push(calcPolygonAreaShoelace(
          intersection.geometry.coordinates[j][0]
        ));
      }
    }
    var interiorarea = areaIntersection.reduce((x, y) => x + y);
    L.geoJson(intersection, { color: "green" }).addTo(maps_proposed[row]);
    console.log('areaIntersection: ', areaIntersection);
    if(interiorarea  <= requiredArea ){
      const areaDiff = requiredArea - interiorarea;
      console.log('areaDiff: ', areaDiff);
      const areaDiffPart = (areaDiff / interiorarea) * areaIntersection[0];
      console.log('areaDiffPart: ', areaDiffPart);
      const LVertex = rearrangedPoints[i];
      console.log('LVertex: ', LVertex);
      // const NVertex = rearrangedPoints[i+1];
      const NVertex = points_proposed[row][pointsSlopesIndex[i]+1];
      console.log('NVertex: ', NVertex);

      const pDist = (2 * areaDiff) / (distance(LVertex, selectedPoint) * Math.sin(anticlockwiseAngle2D(NVertex, LVertex, selectedPoint)*Math.PI/180));
      console.log('pDist: ', pDist);

      const pNewLatLng = [
        LVertex[0] +
        ((NVertex[0] - LVertex[0]) * pDist) / distance(NVertex, LVertex),
        LVertex[1] +
        ((NVertex[1] - LVertex[1]) * pDist) / distance(NVertex, LVertex),
      ];

      console.log('partitionPolygon: ', partitionPolygon);
      console.log('pNewLatLng: ', pNewLatLng);
      var newPolygon = partitionPolygon.splice(partitionPolygon.length-1, 0, pNewLatLng);
      console.log('newPolygon: ', newPolygon);
      L.polygon(L.GeoJSON.coordsToLatLngs(partitionPolygon), {
        color: "red",
      }).addTo(maps_proposed[row]);
      break;
    }
  }
  
  console.timeEnd('Proposed Execution Time');
  maps_habib[1].sync(maps_proposed[1]);
  maps_proposed[1].sync(maps_habib[1]);
</script>

</html>